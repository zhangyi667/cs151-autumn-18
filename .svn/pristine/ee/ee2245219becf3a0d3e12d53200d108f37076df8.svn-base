#lang typed/racket

(require typed/test-engine/racket-tests)

(require "../include/cs151-core.rkt")
(require "../include/cs151-image.rkt")
(require "../include/cs151-universe.rkt")

;; data definitions

(define-struct (Some a)
  ([value : a]))

(define-type (Optional a)
  (U 'None (Some a)))

(define-type Stone
  (U 'black 'white))

(define-struct LogicalLoc
  ([col : Integer]
   [row : Integer]))
   
(define-struct Go
  ([dimension : Integer]
   [black-stones : (Listof LogicalLoc)]
   [white-stones : (Listof LogicalLoc)]
   [next-to-play : Stone]))

(define-struct PhysicalLoc
  ([x-offset-from-left : Integer]
   [y-offset-from-top  : Integer]))

(define-struct BoardSpec
  ([background-color : Image-Color]
   [cell-size-pixels : Integer]
   [margin-pixels : Integer]
   [stone-radius-pixels : Integer]))

(define-struct World
  ([spec : BoardSpec]
   [game : Go]
   [status-message : String]))

;; the integer argument is the dimension (locations per side) of the board
(: logical->physical : LogicalLoc Integer BoardSpec -> PhysicalLoc)
(define (logical->physical ll n bs)
  (match* (ll bs)
    [((LogicalLoc x y) (BoardSpec _ cell mar _))
     (PhysicalLoc (+ mar (* x cell)) (+ mar (* (- n y 1) cell)))]))

;(check-expect (logical->physical (LogicalLoc 1 1) 19 (BoardSpec 'tan 20 12 5))
;              (PhysicalLoc 32 372))
;(check-expect (logical->physical (LogicalLoc 18 2) 19 (BoardSpec 'tan 12 5 4))
;              (PhysicalLoc 221 209))
;(check-expect (logical->physical (LogicalLoc 0 0) 19 (BoardSpec 'tan 24 14 7))
;              (PhysicalLoc 14 470)) 
(check-expect (logical->physical (LogicalLoc 0 0) 3 (BoardSpec 'tan 10 12 3))
              (PhysicalLoc 12 32))
(check-expect (logical->physical (LogicalLoc 1 0) 3 (BoardSpec 'tan 10 12 3))
              (PhysicalLoc 22 32))
(check-expect (logical->physical (LogicalLoc 0 1) 3 (BoardSpec 'tan 10 12 3))
              (PhysicalLoc 12 22))

(: dist : PhysicalLoc PhysicalLoc -> Real)
(define (dist orig calc)
  (match* (orig calc)
      [((PhysicalLoc x y) (PhysicalLoc xx yy))
       (sqrt (+ (sqr (- xx x)) (sqr (- yy y))))]))
    
(: in-margin? : PhysicalLoc Integer BoardSpec -> Boolean)
(define (in-margin? pl n bs)
  (match* (pl bs)
    [((PhysicalLoc x y) (BoardSpec _ cell mar _))
     (local {(define d (+ mar mar (* cell (sub1 n))))}
       (and (<= x d) (<= y d)))]))

;; in-margin checks if the point is in the grid
;; llx and lly are place-holder values that get fed into log-> phy
;; to be compared to the orginal physical location
;; the integer argument is the dimension (locations per side) of the board
(: physical->logical : PhysicalLoc Integer BoardSpec -> (Optional LogicalLoc))
(define (physical->logical pl n bs)
  (if (in-margin? pl n bs)
      (match* (pl bs)
        [((PhysicalLoc x y) (BoardSpec _ cell mar r))
         (local {(define llx (round (/ (- x mar) cell)))
                 (define lly (round (- (sub1 n) (/ (- y mar) cell))))}
           (match (logical->physical (LogicalLoc llx lly) n bs)
             [(PhysicalLoc xx yy) (if (< (dist (PhysicalLoc xx yy) (PhysicalLoc x y)) r)
                                  (Some (LogicalLoc llx lly))
                                  'None)]))])
      'None))

(check-expect
 (physical->logical (PhysicalLoc 12 32) 3 (BoardSpec 'tan 10 12 3))
 (Some (LogicalLoc 0 0)))
(check-expect
 (physical->logical (PhysicalLoc 14 31) 3 (BoardSpec 'tan 10 12 3))
 (Some (LogicalLoc 0 0)))
(check-expect
 (physical->logical (PhysicalLoc 22 32) 3 (BoardSpec 'tan 10 12 3))
 (Some (LogicalLoc 1 0)))
(check-expect
 (physical->logical (PhysicalLoc 250 250) 19 (BoardSpec 'tan 12 5 4)) 'None)
(check-expect
 (physical->logical (PhysicalLoc 90 45) 19 (BoardSpec 'tan 30 5 10)) 'None)
(check-expect
 (physical->logical (PhysicalLoc 27 377) 19 (BoardSpec 'tan 20 12 5)) 'None)                                                           

;; takes an integer and converts it to a char
(: num->let : Integer -> Char)
(define (num->let x)
  (cond
    [(<= x 7) (integer->char (+ 65 x))]
    [else (integer->char (+ 66 x))]))

(check-expect (build-list 10 num->let)
              '(#\A
                #\B
                #\C
                #\D
                #\E
                #\F
                #\G
                #\H
                #\J
                #\K))

;; uses num->let to make a string of appropriate length
(: int->string : Integer -> String)
(define (int->string n)
  (make-string (+ 1 (quotient n 25)) (num->let (remainder n 25))))

(check-expect (build-list 60 int->string) strings)

;; Convert logical locations to strings such as "A1", "B3", etc.
;; Note the letter "I" is skipped in Go labeling.
;; When you get a column past "Z", use "AA", then "BB", then "CC", etc.
;; When you get past "ZZ", use "AAA", then "BBB", etc.
(: logical->string : LogicalLoc -> String)
(define (logical->string ll)
  (match ll
    [(LogicalLoc x y)
       (string-append (int->string x) (number->string (+ y 1)))]))

(check-expect (logical->string (LogicalLoc 0 0)) "A1")
(check-expect (logical->string (LogicalLoc 1 10)) "B11")
(check-expect (logical->string (LogicalLoc 19 19)) "U20")

;; true if the two LogicalLocs are the same position
(: same-ll : LogicalLoc LogicalLoc -> Boolean)
(define (same-ll ll1 ll2)
  (match* (ll1 ll2)
    [((LogicalLoc x1 y1) (LogicalLoc x2 y2))
     (and (= x1 x2) (= y1 y2))]))

;; Return the stone at the specified location on the board,
;; or indicate it is unoccupied
;(: board-ref : Go LogicalLoc -> (Optional Stone))
;(define (board-ref go ll)
;  (match go
;    [(Go _ b w n)
;     (match b
;       [(cons hd tl) (if (= hd ll) hd (board-ref tl))])]))

;; used for check-expect
(: strings : (Listof String))
(define strings
  '("A"
    "B"
    "C"
    "D"
    "E"
    "F"
    "G"
    "H"
    "J"
    "K"
    "L"
    "M"
    "N"
    "O"
    "P"
    "Q"
    "R"
    "S"
    "T"
    "U"
    "V"
    "W"
    "X"
    "Y"
    "Z"
    "AA"
    "BB"
    "CC"
    "DD"
    "EE"
    "FF"
    "GG"
    "HH"
    "JJ"
    "KK"
    "LL"
    "MM"
    "NN"
    "OO"
    "PP"
    "QQ"
    "RR"
    "SS"
    "TT"
    "UU"
    "VV"
    "WW"
    "XX"
    "YY"
    "ZZ"
    "AAA"
    "BBB"
    "CCC"
    "DDD"
    "EEE"
    "FFF"
    "GGG"
    "HHH"
    "JJJ"
    "KKK"))

(test)
#lang typed/racket

(require typed/test-engine/racket-tests)

(require "../include/cs151-core.rkt")
(require "../include/cs151-image.rkt")

(define-struct Date
  ([month : Integer]
   [day   : Integer]
   [year  : Integer]))

(define-type Day
  (U 'Sun 'Mon 'Tue 'Wed 'Thu 'Fri 'Sat))

;; two-digits
(: two-digits : Integer -> String)
(define (two-digits n)
  (cond
    [(< n 10) (string-append "0" (number->string n))]
    [else (number->string n)]))

(check-expect (two-digits 3) "03")
(check-expect (two-digits 10) "10")

;; display the date in "MM/DD/YYYY" format
(: format : Date -> String)
(define (format date)
  (match date
    [(Date m d y) (string-append
                   (two-digits m) "/"
                   (two-digits d) "/"
                   (number->string y))]))

(check-expect (format (Date 1 8 2000)) "01/08/2000")
(check-expect (format (Date 12 22 1999)) "12/22/1999")

;; report the number of days given the month and the year, in that order
(: days-in-month : Integer Integer -> Integer)
(define (days-in-month m y)
  (match* (m y)
    [(1 _) 31]
    [(2 y) (if (= (remainder y 4) 0) 29 28)]
    [(3 _) 31]
    [(4 _) 30]
    [(5 _) 31]
    [(6 _) 30]
    [(7 _) 31]
    [(8 _) 31]
    [(9 _) 30]
    [(10 _) 31]
    [(11 _) 30]
    [(12 _) 31]))

(check-expect (days-in-month 2 2000) 29)
(check-expect (days-in-month 2 2001) 28)
(check-expect (days-in-month 1 2000) 31)
(check-expect (days-in-month 11 2000) 30)

;; a date is valid if it is not past the end of the month (e.g., Feb 30 or Apr 33)
;; and it is between 1900 and 2099 inclusive
(: valid? : Date -> Boolean)
(define (valid? date)
  (match date
    [(Date m d y)
     (and (<= m 12)
          (<= d (days-in-month m y))
          (and (>= y 1900) (<= y 2099)))]))

(check-expect (valid? (Date 1 40 2000)) #f)
(check-expect (valid? (Date 1 30 2100)) #f)
(check-expect (valid? (Date 14 30 2000)) #f)
(check-expect (valid? (Date 12 25 1890)) #f)
(check-expect (valid? (Date 12 25 2005)) #t)

;; Is the first date before the second?
(: before? : Date Date -> Boolean)
(define (before? date1 date2)
  (match* (date1 date2)
    [((Date m1 d1 y1) (Date m2 d2 y2))
     (cond
       [(< y1 y2) #t]
       [(> y1 y2) #f]
       [(< m1 m2) #t]
       [(> m1 m2) #f]
       [(< d1 d2) #t]
       [else #f])]))

(check-expect (before? (Date 1 1 2000) (Date 1 1 1999)) #f)
(check-expect (before? (Date 1 1 2000) (Date 1 1 2001)) #t)
(check-expect (before? (Date 1 1 2000) (Date 2 1 2000)) #t)
(check-expect (before? (Date 3 1 2000) (Date 1 1 2000)) #f)
(check-expect (before? (Date 1 30 2000) (Date 1 20 2000)) #f)
(check-expect (before? (Date 1 20 2000) (Date 1 30 2000)) #t)
(check-expect (before? (Date 3 1 2001) (Date 3 2 2000)) #f)
(check-expect (before? (Date 5 1 2000) (Date 4 1 2000)) #f)

;; Is the first date after the second?
(: after? : Date Date -> Boolean)
(define (after? date1 date2)
  (match* (date1 date2)
    [((Date m1 d1 y1) (Date m2 d2 y2))
     (if (and (= m1 m2) (= d1 d2) (= y1 y2))
         #f
         (not (before? date1 date2)))]))

(check-expect (after? (Date 1 1 2000) (Date 1 1 1999)) #t)
(check-expect (after? (Date 1 1 2000) (Date 1 1 2001)) #f)
(check-expect (after? (Date 1 1 2000) (Date 2 1 2000)) #f)
(check-expect (after? (Date 3 1 2000) (Date 1 1 2000)) #t)
(check-expect (after? (Date 1 30 2000) (Date 1 20 2000)) #t)
(check-expect (after? (Date 1 20 2000) (Date 1 30 2000)) #f)

;; Is the given date the last date of the month?
(: last-of-month? : Date -> Boolean)
(define (last-of-month? date)
  (match date
    [(Date m d y) (= d (days-in-month m y))]))

(check-expect (last-of-month? (Date 2 29 2000)) #t)
(check-expect (last-of-month? (Date 1 31 2018)) #t)
(check-expect (last-of-month? (Date 10 30 2018)) #f)

;; Given a date, return the day immediately after.
(: tomorrow : Date -> Date)
(define (tomorrow date)
  (match date
    [(Date m d y)
     (cond
       [(and (= m 12) (= d 31)) (Date 1 1 (add1 y))]
       [(last-of-month? (Date m d y)) (Date (add1 m) 1 y)]
       [else (Date m (add1 d) y)])]))

(check-expect (tomorrow (Date 12 31 2018)) (Date 1 1 2019))
(check-expect (tomorrow (Date 1 20 2018)) (Date 1 21 2018))
(check-expect (tomorrow (Date 10 31 2018)) (Date 11 1 2018))

;; Given a date, return the day immediately before.
(: yesterday : Date -> Date)
(define (yesterday date)
  (match date
    [(Date m d y)
     (cond
       [(and (= m 1) (= d 1)) (Date 12 31 (sub1 y))]
       [(= d 1) (Date (sub1 m) (days-in-month (sub1 m) y) y)]
       [else (Date m (sub1 d) y)])]))

(check-expect (yesterday (Date 1 1 2019)) (Date 12 31 2018))
(check-expect (yesterday (Date 1 21 2018)) (Date 1 20 2018))
(check-expect (yesterday (Date 11 1 2018)) (Date 10 31 2018))

(: num-times 

;; Given a date, advance that many days on the calendar.
;; If the integer is positive, this means move ahead in time.
;; If the integer is negative, this means move back in time.
(: add-days : Integer Date -> Date)
(define (add-days n date)
  (match n
    [0 date]
    [(positive? n) (if (> n 0) (tomorrow date)


(test)
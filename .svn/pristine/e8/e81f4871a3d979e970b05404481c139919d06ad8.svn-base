#lang typed/racket

(require typed/test-engine/racket-tests)
(require "../include/cs151-core.rkt")

(define-struct (Some a)
  ([value : a]))

(define-type (Optional a)
  (U 'None (Some a)))

(define-type Candidate
  Symbol)
  
(define-type Ballot
  (Listof Candidate))

(define-type Ballots
  (Listof Ballot))

(define-struct CandCount
  ([cand  : Candidate]
   [count : Integer]))

(define-type Tally
  (Listof CandCount))

;; true if candidate doesn't have a CandCount
;; and a new CandCount has to be made
(: need-CandCount? : Candidate Tally -> Boolean)
(define (need-CandCount? candidate list)
  (match list
    ['() #t]
    [(cons hd tl)
     (match hd
       [(CandCount cand _)
        (and (not (symbol=? candidate cand)) (need-CandCount? candidate tl))])]))

(check-expect (need-CandCount? 'B (list (CandCount 'B 10) (CandCount 'C 10))) #f)
(check-expect (need-CandCount? 'A (list (CandCount 'B 10) (CandCount 'C 10))) #t)
(check-expect (need-CandCount? 'C (list (CandCount 'B 10) (CandCount 'C 10))) #f)

;; add one to candidate count inside Tally
(: add-count : Candidate Tally -> Tally)
(define (add-count newcand tally)
  (match tally
    [(cons h t)
     (match h
       [(CandCount cand count)
        (if (symbol=? cand newcand)
            (cons (CandCount cand (add1 count)) t)
            (cons h (add-count newcand t)))])]))
            
;; if the candidate is found in the Tally, increase the count
;; if the candidate is not found in Tally, create a CandCount
(: respond-to-cand : Candidate Tally -> Tally)
(define (respond-to-cand cand tally)
  (if (need-CandCount? cand tally)
      (cons (CandCount cand 1) tally)
      (add-count cand tally)))

(check-expect (respond-to-cand 'A (list (CandCount 'B 10) (CandCount 'C 10)))
              (list (CandCount 'A 1) (CandCount 'B 10) (CandCount 'C 10)))
(check-expect (respond-to-cand 'C (list (CandCount 'B 10) (CandCount 'C 10)))
              (list (CandCount 'B 10) (CandCount 'C 11)))
(check-expect (respond-to-cand 'B (list (CandCount 'B 10) (CandCount 'C 10)))
              (list (CandCount 'B 11) (CandCount 'C 10)))

(define sample-ballots
  (list (list 'A 'C 'B) (list 'A 'B) (list 'B 'C) (list 'C 'B 'A) (list 'C 'B)))

;; Count all the first-choice votes in the current round.
(: tally : Ballots -> Tally)
(define (tally ballots)
  (local {(define list-cand (choice1 ballots))}
    (if (> (length list-cand) 0)
        (match ballots
          ['() '()]
          [_ (respond-to-cand (first list-cand) (tally (rest ballots)))])
        '())))

(check-expect (tally (list (list 'A 'B) (list 'A 'B) (list 'B)))
              (list (CandCount 'A 2) (CandCount 'B 1)))
(check-expect (tally sample-ballots)
              (list (CandCount 'A 2) (CandCount 'B 1) (CandCount 'C 2)))

;; returns a list of the first choices of a list of ballots
(: choice1 : Ballots -> (Listof Candidate))
(define (choice1 list)
  (match list
    ['() '()]
    [(cons h t)
     (match h
       ['() '()]
       [(cons hd _) (cons hd (choice1 t))])]))

(check-expect (choice1 sample-ballots) '(A A B C C))
(check-expect (choice1 '((A B C) (B C A))) '(A B))

;; returns the most votes of one candidate
(: most : Tally -> Integer)
(define (most list)
  (foldr (lambda ([a : CandCount] [b : Integer])
           (max (CandCount-count a) b)) 0 list))

;; sum of votes
(: sum-votes : Tally -> Integer)
(define (sum-votes list)
  (foldr (lambda ([a : CandCount] [b : Integer])
           (+ (CandCount-count a) b)) 0 list))
;  (match list
;    ['() 0]
;    [(cons h t)
;     (match h
;       [(CandCount _ count)
;        (+ count (sum-votes t))])]))

;; true if one candidate has the majority of the votes
(: majority? : Tally -> Boolean)
(define (majority? tally)
  (if (> (sum-votes tally) 0)
      (> (/ (most tally) (sum-votes tally)) 1/2)
      #f))

;; find the candidate given how many votes they have earned
;; this assumes there are no ties
;; only used for winner?, because there cannot be a tie for winner
(: find-cand : Integer Tally -> Candidate)
(define (find-cand votes tally)
  (match tally
    ['() 'None]
    [(cons hd tl)
     (match hd
       [(CandCount cand count)
        (if (= count votes)
            cand
            (find-cand votes tl))])]))

(check-expect (find-cand 10 (list (CandCount 'A 40) (CandCount 'B 30) (CandCount 'C 10))) 'C)

;; Is there a winner in *this* round?
;; That is, tally the votes in the current round, and return Some winner if
;; there exists a majority for a candidate. Otherwise, return 'None.
(: winner? : Ballots -> (Optional Candidate))
(define (winner? ballots)
  (local {(: local-tally : Tally)
          (define local-tally (tally ballots))}
    (if (majority? local-tally)
        (Some (find-cand (most local-tally) local-tally))
        'None)))

;; min number of votes a candidate got
(: least : Tally -> Integer)
(define (least list)
  (foldr (lambda ([a : CandCount] [b : Integer])
           (min (CandCount-count a) b)) (most list) list))

(check-expect (least (tally sample-ballots)) 1)

;; finds a list of candidates in a tally instead of just one
;; is only used in losing
(: find-losing : Integer Tally -> (Listof Candidate))
(define (find-losing votes tally)
  (match tally
    ['() '()]
    [(cons hd tl)
     (match hd
       [(CandCount cand count)
        (if (= count votes)
            (cons cand (find-losing votes tl))
            (find-losing votes tl))])]))

(check-expect (find-losing 1 (tally sample-ballots)) '(B))

;; finds the losing candidate(s)
(: losing : Ballots -> (Listof Candidate))
(define (losing ballots)
  (local {(: local-tally : Tally)
          (define local-tally (tally ballots))}
    (find-losing (least local-tally) local-tally)))

(check-expect (losing sample-ballots) '(B))
(check-expect (losing (list '(A C B) '(A B) '(B C) '(B) '(C B A) '(C B))) '(A B C))

;; true if candidate is found in list of losing candidates
(: is-found? : Candidate (Listof Candidate) -> Boolean)
(define (is-found? cand list)
  (match list
    ['() #f]
    [(cons hd tl) (or (symbol=? cand hd)                     
                      (is-found? cand tl))]))

(check-expect (is-found? 'A '(C B E T EE A)) #t)
(check-expect (is-found? 'A '(C B E)) #f)

;; removes proper candidates
(: remove : Ballots (Listof Candidate) -> Ballots)
(define (remove ballots losinglist)
  (match ballots
    ['() '()]
    [(cons ballot tail)
     (match ballot
       ['() '()]
       [(cons first rest)
        (if (is-found? first losinglist)
            (cons rest (remove tail losinglist))
            (cons ballot (remove tail losinglist)))])]))

;; removes the first choice votes for the losing candidate(s)
(: choice2 : Ballots -> Ballots)
(define (choice2 ballots)
  (remove ballots (losing ballots)))

;; Run rounds until Some winner is found. 
;; Eliminate the trailing candidate (or candidates if there is a tie) after each round.
;; Return 'None in case of no majority after any round, and no more rounds to run.
(: election : Ballots -> (Optional Candidate))
(define (election ballots)
  (if (> (length ballots) 0)
      (match (winner? ballots)
        ['None (election (choice2 ballots))]
        [(Some cand) (Some cand)])
      'None))

(check-expect (election (list '(A B C) '(B C A) '(A B C) '(B A A))) (Some 'C))
(check-expect (election (list (list 'A 'B) (list 'A 'C) (list 'D 'B) (list 'D 'C) (list 'B 'A) (list 'C 'A))) (Some 'A))
(check-expect (election (list '(A) '(B) '(C) '(D))) 'None)

;; prints out losing candidates as strings
(: print-losing : Ballot -> String)
(define (print-losing list)
  (match list
    ['() ""]
    [(cons hd tl) (string-append (symbol->string hd) ", " (print-losing tl))]))

;; print the winner
(: print-winner : (Optional Candidate) -> String)
(define (print-winner cand)
  (match cand
    ['None "NONE"]
    [(Some cand) (symbol->string cand)]))

;; Build a string in plain English that describes the election. The exact wording
;; is up to you, but the following requirements must be met. The number of rounds
;; must be included in the report. The candidate or candidates eliminated in each
;; round must be identified. The report must be in grammatically correct language
;; suitable for reading by a general reader.
(: election-report : Ballots -> String)
(define (election-report ballots)
  (string-append "There were a number of rounds, with losing candidates "
                 "being eliminated in the following order: "
                 (print-losing (losing ballots))
                 "and the winning candidate was "
                 (print-winner (election ballots))))
                 
;  (local {(: lp : Integer -> Integer)
;          (define (lp n)
;            (match (winner? ballots)
;              [(Some cand) 1]
;              [_ (begin (winner? (choice2 ballots)) (lp (+ n 1)))]))}
;    (lp 0)))

  
;  (if (> (length ballots) 0)
;      (match (winner? ballots)
;        ['None (begin (election (choice2 ballots)))

(test)
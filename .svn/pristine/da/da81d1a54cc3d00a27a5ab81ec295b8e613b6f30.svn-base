#lang typed/racket
(require typed/test-engine/racket-tests)
(require "../include/cs151-core.rkt")

;; PROBLEM 1

(define-struct Salary
  ([per-period : Exact-Rational]
   [periods-per-year : Integer]
   [min-hours-week : Integer]))

(define-struct Wage
  ([hourly : Exact-Rational]
   [max-hours-week : Integer]))

(define-type Job (U Salary Wage))

;; error?: returns true if given any nonsensical negative input or if
;; number of hours per week exceeds 80
(: error? (Job -> Boolean))
(define (error? j)
  (match j
    [(Salary pay per min) (or (< pay 0) (< per 0) (< min 0))]
    [(Wage pay max) (or (< pay 0) (< max 0) (> max 80))]))

(check-expect (error? (Salary 1000 24 -10)) #t)
(check-expect (error? (Wage 20 82)) #t)

;; annual-income: given a Job and number of hours worked per week, calculate
;; the annual income. If salaried employee does not work min number of hours,
;; income is 0. If paid wages, there is no benefit to working over max hours
(: annual-income : Job Integer -> Exact-Rational)
(define (annual-income j i)
  [if (error? j) (error "annual-income: given negative or exeeding 80 hrs/wk")
      (match j    
        [(Salary pay per min) (if (< i min) 0 (* pay per))]
        [(Wage pay max) (if (> i max) (* pay max) (* pay i))])])

(check-expect (annual-income (Salary 4000 12 40) 40) 48000)
(check-expect (annual-income (Salary 4000 12 40) 30) 0)
(check-expect (annual-income (Wage 20 60) 40) 800)
(check-expect (annual-income (Wage 20 60) 80) 1200)
(check-error (annual-income (Salary -9 1 1) 1) "annual-income: given negative or exeeding 80 hrs/wk")

;; hourly-rate: calculates effictive hourly rate being paid at given job
(: hourly-rate : Job Integer -> Exact-Rational)
(define (hourly-rate j i)
  [if (error? j) (error "hourly-rate: given negative or exeeding 80 hrs/wk")
      (match j    
        [(Salary _ _ min) (/ (annual-income j i) min 52)]
        [(Wage pay _) pay])])

(check-expect (hourly-rate (Salary 4000 12 40) 30) 0)
(check-within (hourly-rate (Salary 100000 1 40) 42) 48.0769 0.001)
(check-expect (hourly-rate (Wage 25 50) 40) 25)

;; job=?: determines if two jobs are exactly the same in terms of hours and
;; money earned
(: job=? : Job Job -> Boolean)
(define (job=? j1 j2)
  (match* (j1 j2)
    [((Salary a1 b1 c1) (Salary a2 b2 c2)) (and (= a1 a2) (= b1 b2) (= c1 c2))]
    [((Wage a1 b1) (Wage a2 b2)) (and (= a1 a2) (= b1 b2))]
    [(_ _) #f]))

(check-expect (job=? (Salary 1000 12 40) (Salary 1000 12 30)) #f)
(check-expect (job=? (Salary 1000 12 40) (Salary 1000 12 40)) #t)
(check-expect (job=? (Salary 1000 12 40) (Wage 40 40)) #f)
(check-expect (job=? (Wage 12 40) (Wage 12 40)) #t)

;; earnings>?: determines if the first has more earnings potential than the second
(: earnings>? : Job Job -> Boolean)
(define (earnings>? j1 j2)
  (match* (j1 j2)
    [((Salary pay per _) (Wage hour max)) (> (* pay per) (* hour max 52))]
    [((Wage hour max) (Salary pay per _)) (> (* hour max 52) (* pay per))]))

(check-expect (earnings>? (Salary 10000 12 40) (Wage 20 60)) #t)
(check-expect (earnings>? (Wage 500 20) (Salary 1000 24 40)) #t)

;; PROBLEM 2

(define-type Player (U 'Black 'White))
(define-type PieceType (U 'Pawn 'Bishop 'Knight 'Rook 'Queen 'King))
(define-struct ChessPiece
  ([color : Player]
   [type : PieceType]))

;; points: assigns points to a piece, with pawn = 1, bishop = 3, knight = 3
;; rook = 5, queen = 9, king = 0
(: points : ChessPiece -> Integer)
(define (points p)
  (match p
    [(ChessPiece _ 'Pawn) 1]
    [(ChessPiece _ (or 'Bishop 'Knight)) 3]
    [(ChessPiece _ 'Rook) 5]
    [(ChessPiece _ 'Queen) 9]
    [(ChessPiece _ _ ) 0]))
    
(check-expect (points (ChessPiece 'Black 'King)) 0)
(check-expect (points (ChessPiece 'White 'Bishop)) 3)

;; to-letter: helper function for piece->char that converts the piece
;; type to a lowercase letter
(: to-letter (PieceType -> Char))
(define (to-letter s)
  (match s
    ['Pawn #\p]
    ['Bishop #\b]
    ['Knight #\n]
    ['Rook #\r]
    ['Queen #\q]
    ['King #\k]))

(check-expect (to-letter 'Knight) #\n)

;; piece->char: takes in a ChessPiece and returns an abbreviation:
;; uppercase letters for black, lowercase letters for white
;; P = pawn, B = bishop, N = knight, R = rook, Q = queen, K = king
(: piece->char : ChessPiece -> Char)
(define (piece->char p)
  (match p
    [(ChessPiece 'Black f) (char-upcase (to-letter f))]
    [(ChessPiece 'White f) (to-letter f)]))

(check-expect (piece->char (ChessPiece 'Black 'King)) #\K)
(check-expect (piece->char (ChessPiece 'White 'Rook)) #\r)

(: to-piece (Char -> PieceType))
(define (to-piece c)
  (match c
    [#\p 'Pawn]
    [#\b 'Bishop]
    [#\n 'Knight]
    [#\r 'Rook]
    [#\q 'Queen]
    [#\k 'King]
    [_ (error "char->piece: piece does not exist")]))

(check-expect (to-piece #\p) 'Pawn)

;; char->piece: given a character, return the matching ChessPiece
;; raises error if character does not match a piece
(: char->piece : Char -> ChessPiece)
(define (char->piece c)
  (cond
    [(char-upper-case? c) (ChessPiece 'Black (to-piece (char-downcase c)))]
    [else (ChessPiece 'White (to-piece c))])) 

(check-expect (char->piece #\K) (ChessPiece 'Black 'King))
(check-error (char->piece #\a) "char->piece: piece does not exist")
(check-expect (char->piece #\b) (ChessPiece 'White 'Bishop))



(test)
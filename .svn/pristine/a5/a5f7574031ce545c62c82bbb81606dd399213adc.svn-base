#lang typed/racket

(require typed/test-engine/racket-tests)
(require "../include/cs151-core.rkt")

(define-struct (Some a)
  ([value : a]))

(define-type (Optional a)
  (U 'None (Some a)))

(define-type Candidate
  Symbol)
  
(define-type Ballot
  (Listof Candidate))

(define-type Ballots
  (Listof Ballot))

(define-struct CandCount
  ([cand  : Candidate]
   [count : Integer]))

(define-type Tally
  (Listof CandCount))

;; true if candidate doesn't have a CandCount
;; and a new CandCount has to be made
(: need-CandCount? : Candidate Tally -> Boolean)
(define (need-CandCount? candidate list)
  (match list
    ['() #t]
    [(cons hd tl)
     (match hd
       [(CandCount cand _)
        (and (not (symbol=? candidate cand)) (need-CandCount? candidate tl))])]))

(check-expect (need-CandCount? 'B (list (CandCount 'B 10) (CandCount 'C 10))) #f)
(check-expect (need-CandCount? 'A (list (CandCount 'B 10) (CandCount 'C 10))) #t)
(check-expect (need-CandCount? 'C (list (CandCount 'B 10) (CandCount 'C 10))) #f)

;; add one to candidate count inside Tally
(: add-count : Candidate Tally -> Tally)
(define (add-count newcand tally)
  (match tally
    [(cons h t)
     (match h
       [(CandCount cand count)
        (if (symbol=? cand newcand)
            (cons (CandCount cand (add1 count)) t)
            (cons h (add-count newcand t)))])]))
            
;; if the candidate is found in the Tally, increase the count
;; if the candidate is not found in Tally, create a CandCount
(: respond-to-cand : Candidate Tally -> Tally)
(define (respond-to-cand cand tally)
  (if (need-CandCount? cand tally)
      (cons (CandCount cand 1) tally)
      (add-count cand tally)))

(check-expect (respond-to-cand 'A (list (CandCount 'B 10) (CandCount 'C 10)))
              (list (CandCount 'A 1) (CandCount 'B 10) (CandCount 'C 10)))
(check-expect (respond-to-cand 'C (list (CandCount 'B 10) (CandCount 'C 10)))
              (list (CandCount 'B 10) (CandCount 'C 11)))
(check-expect (respond-to-cand 'B (list (CandCount 'B 10) (CandCount 'C 10)))
              (list (CandCount 'B 11) (CandCount 'C 10)))

(define sample-ballots
  (list (list 'A 'C 'B) (list 'A 'B) (list 'B 'C) (list 'C 'B 'A) (list 'C 'B)))

;; Count all the first-choice votes in the current round.
(: tally : Ballots -> Tally)
(define (tally ballots)
  (local {(define list-cand (choice1 ballots))}
    (match ballots
      ['() '()]
      [_ (respond-to-cand (first list-cand) (tally (rest ballots)))])))
; (first (first ballots))
; instead of
; (first list-cand)
;
;  (match ballots
;    ['() '()]
;    [(cons _ tl)
;     (local {(define list-cand (choice1 ballots))}
;       (match list-cand
;         ['() '()]
;         [(cons cand rest) (respond-to-cand cand (tally tl))]))]))

(check-expect (tally (list (list 'A 'B) (list 'A 'B) (list 'B)))
              (list (CandCount 'A 2) (CandCount 'B 1)))
(check-expect (tally sample-ballots)
              (list (CandCount 'A 2) (CandCount 'B 1) (CandCount 'C 2)))

;; returns a list of the first choices of a list of ballots
(: choice1 : Ballots -> (Listof Candidate))
(define (choice1 list)
  (match list
    ['() '()]
    [(cons h t)
     (match h
       ['() '()]
       [(cons hd _) (cons hd (choice1 t))])]))

(check-expect (choice1 sample-ballots) '(A A B C C))
(check-expect (choice1 '((A B C) (B C A))) '(A B))

;; returns the most votes of one candidate
(: most : Tally -> Integer)
(define (most list)
  (foldr (lambda ([a : CandCount] [b : Integer])
           (max (CandCount-count a) b)) 0 list))
 

;; sum of votes
(: sum-votes : Tally -> Integer)
(define (sum-votes list)
  (foldr (lambda ([a : CandCount] [b : Integer])
           (+ (CandCount-count a) b)) 0 list))
;  (match list
;    ['() 0]
;    [(cons h t)
;     (match h
;       [(CandCount _ count)
;        (+ count (sum-votes t))])]))

;; true if one candidate has the majority of the votes
(: majority? : Tally -> Boolean)
(define (majority? tally)
  (> (/ (most tally) (sum-votes tally)) 1/2))

;; Is there a winner in *this* round?
;; That is, tally the votes in the current round, and return Some winner if
;; there exists a majority for a candidate. Otherwise, return 'None.
;(: winner? : Ballots -> (Optional Candidate))
;(define (winner? ballots)
;  (match (tally ballots)
;    ['() 'None]
;    [(cons hd tl)
;     (match hd
;       [(CandCount cand count)

(test)
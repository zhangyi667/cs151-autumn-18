#lang typed/racket

(require typed/test-engine/racket-tests)

(require "../include/cs151-core.rkt")
(require "../include/cs151-image.rkt")

(define-struct Date
  ([month : Integer]
   [day   : Integer]
   [year  : Integer]))

(define-type Day
  (U 'Sun 'Mon 'Tue 'Wed 'Thu 'Fri 'Sat))

;; two-digits
(: two-digits : Integer -> String)
(define (two-digits n)
  (cond
    [(< n 10) (string-append "0" (number->string n))]
    [else (number->string n)]))

(check-expect (two-digits 3) "03")
(check-expect (two-digits 10) "10")

;; display the date in "MM/DD/YYYY" format
(: format : Date -> String)
(define (format date)
  (match date
    [(Date m d y) (string-append
                   (two-digits m) "/"
                   (two-digits d) "/"
                   (number->string y))]))

(check-expect (format (Date 1 8 2000)) "01/08/2000")
(check-expect (format (Date 12 22 1999)) "12/22/1999")

;; report the number of days given the month and the year, in that order
(: days-in-month : Integer Integer -> Integer)
(define (days-in-month m y)
  (match* (m y)
    [(1 _) 31]
    [(2 y) (if (= (remainder y 4) 0) 29 28)]
    [(3 _) 31]
    [(4 _) 30]
    [(5 _) 31]
    [(6 _) 30]
    [(7 _) 31]
    [(8 _) 31]
    [(9 _) 30]
    [(10 _) 31]
    [(11 _) 30]
    [(12 _) 31]))

(check-expect (days-in-month 2 2000) 29)
(check-expect (days-in-month 2 2001) 28)
(check-expect (days-in-month 1 2000) 31)
(check-expect (days-in-month 11 2000) 30)

;; a date is valid if it is not past the end of the month (e.g., Feb 30 or Apr 33)
;; and it is between 1900 and 2099 inclusive
(: valid? : Date -> Boolean)
(define (valid? date)
  (match date
    [(Date m d y)
     (and (<= m 12)
          (<= d (days-in-month m y))
          (and (>= y 1900) (<= y 2099)))]))

(check-expect (valid? (Date 1 40 2000)) #f)
(check-expect (valid? (Date 1 30 2100)) #f)
(check-expect (valid? (Date 14 30 2000)) #f)
(check-expect (valid? (Date 12 25 1890)) #f)
(check-expect (valid? (Date 12 25 2005)) #t)

;; Is the first date before the second?
(: before? : Date Date -> Boolean)
(define (before? date1 date2)
  (match* (date1 date2)
    [((Date m1 d1 y1) (Date m2 d2 y2))
     (cond
       [(< y1 y2)]
       [(< m1 m2)]
       [(< d1 d2)]
       [else #f])]))

(check-expect (before? (Date 1 1 2000) (Date 1 1 1999)) #f)
(check-expect (before? (Date 1 1 2000) (Date 1 1 2001)) #t)
(check-expect (before? (Date 1 1 2000) (Date 2 1 2000)) #t)
(check-expect (before? (Date 3 1 2000) (Date 1 1 2000)) #f)
(check-expect (before? (Date 1 30 2000) (Date 1 20 2000)) #f)
(check-expect (before? (Date 1 20 2000) (Date 1 30 2000)) #t)

;; Is the first date after the second?
(: after? : Date Date -> Boolean)
(define (after? date1 date2)
  (match* (date1 date2)
    [((Date m1 d1 y1) (Date m2 d2 y2))
     (if (and (= m1 m2) (= d1 d2) (= y1 y2))
         #f
         (not (before? date1 date2)))]))

(check-expect (after? (Date 1 1 2000) (Date 1 1 1999)) #t)
(check-expect (after? (Date 1 1 2000) (Date 1 1 2001)) #f)
(check-expect (after? (Date 1 1 2000) (Date 2 1 2000)) #f)
(check-expect (after? (Date 3 1 2000) (Date 1 1 2000)) #t)
(check-expect (after? (Date 1 30 2000) (Date 1 20 2000)) #t)
(check-expect (after? (Date 1 20 2000) (Date 1 30 2000)) #f)

;; Is the given date the last date of the month?
(: last-of-month? : Date -> Boolean)
(define (last-of-month? date)
  (match date
    [(Date m d y) (= d (days-in-month m y))]))

(check-expect (last-of-month? (Date 2 29 2000)) #t)
(check-expect (last-of-month? (Date 1 31 2018)) #t)
(check-expect (last-of-month? (Date 10 30 2018)) #f)

;; Given a date, return the day immediately after.
(: tomorrow : Date -> Date)
(define (tomorrow date)
  (match date
    [(Date m d y) 

(test)